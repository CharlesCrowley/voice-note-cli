#!/bin/bash

set -e

# If first argument is "stop", run vn-stop instead
if [ "$1" = "stop" ]; then
    shift
    exec "$(dirname "${BASH_SOURCE[0]}")/vn-stop" "$@"
fi

STATE_DIR="/tmp/vn_state"
PID_FILE="$STATE_DIR/vn.pid"
AUDIO_PATH_FILE="$STATE_DIR/vn_audio_path.txt"
OUTPUT_PATH_FILE="$STATE_DIR/vn_output_path.txt"
MAX_DURATION=3600

show_elapsed_time() {
    local start_time=$1
    while kill -0 $RECORD_PID 2>/dev/null; do
        local elapsed=$(($(date +%s) - start_time))
        local minutes=$((elapsed / 60))
        local seconds=$((elapsed % 60))
        printf "\râ±ï¸  %02d:%02d" $minutes $seconds
        sleep 1

        if [ $elapsed -ge $MAX_DURATION ]; then
            echo ""
            echo "â±ï¸  1 hour limit reached - stopping recording"
            kill $RECORD_PID 2>/dev/null || true
            cleanup_without_transcribe
            exit 0
        fi
    done
}

cleanup_without_transcribe() {
    if [ -f "$AUDIO_PATH_FILE" ]; then
        AUDIO_PATH=$(cat "$AUDIO_PATH_FILE")
        rm -f "$AUDIO_PATH" 2>/dev/null || true
    fi
    rm -rf "$STATE_DIR" 2>/dev/null || true
}

cleanup_on_cancel() {
    echo ""
    echo "âš ï¸  Recording cancelled"
    echo "ğŸ§¹ Cleaning up..."
    kill $RECORD_PID 2>/dev/null || true
    cleanup_without_transcribe
    echo "âœ… Files deleted"
    exit 0
}

if [ -f "$PID_FILE" ]; then
    EXISTING_PID=$(cat "$PID_FILE")
    if kill -0 $EXISTING_PID 2>/dev/null; then
        echo "âŒ Recording already in progress"
        echo "Run 'vn stop' to finish current recording"
        exit 1
    else
        echo "âš ï¸  Stale recording detected, cleaning up..."
        cleanup_without_transcribe
    fi
fi

if ! command -v sox &> /dev/null; then
    echo "âŒ Error: sox not installed"
    echo "Install with: brew install sox"
    exit 1
fi

OUTPUT_PATH=""
if [ -n "$1" ]; then
    OUTPUT_PATH=$(cd "$(dirname "$1")" 2>/dev/null && pwd)/$(basename "$1") || {
        PARENT_DIR=$(dirname "$1")
        if [[ "$1" = /* ]]; then
            OUTPUT_PATH="$1"
        elif [[ "$1" = ~* ]]; then
            OUTPUT_PATH="${1/#\~/$HOME}"
        else
            OUTPUT_PATH="$(pwd)/$1"
        fi

        mkdir -p "$(dirname "$OUTPUT_PATH")" 2>/dev/null || {
            echo "âŒ Cannot create directory: $(dirname "$OUTPUT_PATH")"
            exit 1
        }
    }
fi

mkdir -p "$STATE_DIR"

TIMESTAMP=$(date +%Y%m%d_%H%M%S)
AUDIO_PATH="$STATE_DIR/vn_${TIMESTAMP}.wav"

echo "$$" > "$PID_FILE"
echo "$AUDIO_PATH" > "$AUDIO_PATH_FILE"

if [ -n "$OUTPUT_PATH" ]; then
    echo "$OUTPUT_PATH" > "$OUTPUT_PATH_FILE"
    echo "ğŸ™ï¸  Recording started (will save to: $OUTPUT_PATH)"
else
    echo "ğŸ™ï¸  Recording started"
fi

trap cleanup_on_cancel INT

# Start recording in a way that survives parent shell exit
# Use a subshell with nohup, redirect all output, and use & to background
(
    trap '' HUP
    rec -q "$AUDIO_PATH" rate 16k channels 1 </dev/null >/dev/null 2>&1
) &
RECORD_PID=$!

# Give it a moment to start
sleep 0.1

# Verify it started
if ! kill -0 $RECORD_PID 2>/dev/null; then
    echo "âŒ Failed to start recording"
    rm -rf "$STATE_DIR"
    exit 1
fi

START_TIME=$(date +%s)

echo "Run 'vn stop' when finished"
echo ""

# Run timer in background to enforce 1-hour limit
(
    trap '' HUP
    while kill -0 $RECORD_PID 2>/dev/null; do
        sleep 1
        elapsed=$(($(date +%s) - $START_TIME))
        if [ $elapsed -ge $MAX_DURATION ]; then
            kill $RECORD_PID 2>/dev/null || true
            rm -f "$AUDIO_PATH" 2>/dev/null || true
            rm -rf "$STATE_DIR" 2>/dev/null || true
            exit 0
        fi
    done
) </dev/null >/dev/null 2>&1 &

# Exit immediately, returning control to user
exit 0
